#version 450

#extension GL_EXT_shader_16bit_storage: require
#extension GL_EXT_shader_8bit_storage: require
#extension GL_KHR_shader_subgroup_ballot: require
#extension GL_GOOGLE_include_directive: require 

#include "mesh.h"

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

layout(push_constant) uniform param_block {
    CullingData constant;
};

layout(binding = 0) readonly buffer MeshDraws {
    MeshDraw mesh_draws[];
};

layout(binding = 1) writeonly buffer MeshDrawCommands {
    MeshDrawCommand commands[];
};
layout(binding = 2) writeonly buffer DrawCommandCount {
	uint draw_command_count;
};

layout(binding = 3) readonly buffer MeshletDraws {
    MeshletDraw meshlets[];
};

bool ConeCull(vec4 cone, vec3 view) {
    return dot(cone.xyz, view) > cone.w;
}

vec3 RotateQuat(vec3 v, vec4 q)
{
   return v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);
}

bool ConeCull(vec3 center, float radius, vec3 cone_axis, float cone_cutoff, vec3 camera_position)
{
    return dot(center - camera_position, cone_axis) >= cone_cutoff * length(center - camera_position) + radius;
}

void main() {
    uint ti = gl_LocalInvocationID.x; // SV_GroupThreadID
    uint gi = gl_WorkGroupID.x; // SV_GroupID	
    uint dti = gl_GlobalInvocationID.x; // SV_DispatchThreadID

    if (dti >= constant.draw_count)
        return;

    const uint max_meshlet = 500;
    uint meshlet_index = dti % max_meshlet;
    uint mesh_index = dti / max_meshlet; 

    MeshDraw draw = mesh_draws[mesh_index];
    vec3 center = draw.scale * draw.center + draw.position;
    float radius = draw.scale * draw.radius;

    bool cull = false;
    for (uint i = 0; i < 6; i++) 
        cull = cull || (dot(constant.frustum[i], vec4(center, 1.0)) <= -radius);

    if (cull) return;

    uint mi = meshlet_index;
    {
        vec3 center = RotateQuat(meshlets[mi].center, draw.orientation) * draw.scale + draw.position;
        float radius = meshlets[mi].radius * draw.scale;

        vec4 cone = vec4(ivec4(meshlets[mi].cone)) / 127.0;
        vec3 cone_axis = RotateQuat(cone.xyz, draw.orientation);
        float cone_cutoff = cone.w;

        cull = (ConeCull(center, radius, cone_axis, cone_cutoff, vec3(0, 0, 0)));
        if (cull) return;
    }

    uint slot = atomicAdd(draw_command_count, 1);

    commands[slot].index_count = meshlets[mi].index_count;
    commands[slot].instance_count = 1;
    commands[slot].first_index = meshlets[mi].index_offset;
    commands[slot].vertex_offset = 0;
    commands[slot].first_instance = mesh_index;
}
