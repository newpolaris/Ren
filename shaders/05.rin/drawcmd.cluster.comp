#version 450

#extension GL_EXT_shader_16bit_storage: require
#extension GL_EXT_shader_8bit_storage: require
#extension GL_GOOGLE_include_directive: require 

#include "mesh.h"

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

layout(push_constant) uniform param_block {
    CullingData constant;
};

layout(binding = 0) readonly buffer MeshDraws {
    MeshDraw mesh_draws[];
};

layout(binding = 1) writeonly buffer MeshDrawCommands {
    MeshDrawCommand commands[];
};
layout(binding = 2) writeonly buffer DrawCommandCount {
	uint draw_command_count;
};

layout(binding = 3) readonly buffer MeshletDraws {
    MeshletDraw meshlet_draws[];
};

void main() {
    uint ti = gl_LocalInvocationID.x; // SV_GroupThreadID
    uint gi = gl_WorkGroupID.x; // SV_GroupID	
    uint dti = gl_GlobalInvocationID.x; // SV_DispatchThreadID

    if (dti >= constant.draw_count)
        return;

    MeshDraw draw = mesh_draws[dti];
    vec3 center = draw.scale * draw.center + draw.position;
    float radius = draw.scale * draw.radius;

    bool cull = false;
    for (uint i = 0; i < 6; i++) 
        cull = cull || (dot(constant.frustum[i], vec4(center, 1.0)) <= -radius);

    if (cull)
        return;

    uint meshlet_offset = draw.meshlet_offset;
    uint meshlet_count = draw.meshlet_count;

    uint base = atomicAdd(draw_command_count, meshlet_count);

    for (uint i = 0; i < meshlet_count; i++) {
        uint offset = base + i;  
        MeshletDraw meshlet_draw = meshlet_draws[meshlet_offset + i];
        commands[offset].index_count = meshlet_draw.index_count;
        commands[offset].instance_count = 1;
        commands[offset].first_index = meshlet_draw.index_offset;
        commands[offset].vertex_offset = 0;
        commands[offset].first_instance = dti;
    }
}
